​	Initially, when we were thinking about how we wanted to implement our project, we were leaning towards using Javascript and Node.js to execute our front-end and back-end, however we quickly ran into issues with our lack of experience with Javascript, as well as generally lacking information on how to use APIs, but thanks to our TA’s suggestion, we became aware of a Spotify API Python library called `Spotipy`, which meshed well with us because we had previous experience coding with Python. We thus pivoted to using the `Spotipy` library, also adopting `Flask` to use as a Python framework. We also decided to host our site and server on `Heroku`, which we had previously been incorrectly attempting to do using Netlify, a static web host. 

​	One of the first things we implemented was our search algorithm. At first we had trouble navigating the Spotify API since it was difficult for us to interpret having no prior experience. Eventually, we used the Spotipy library in conjunction with the Spotify API to start building up the algorithm. We started just by creating an empty playlist, then progressed to adding a specific song, then adding multiple songs based on each word in a given input, then finally adding songs that exactly matched each word to a new playlist. We decomposed the user’s sentence into a list of tokens, then iteratively searched for tracks through Spotify with each token. Going through the results of the search, we would add the first song whose title case-insensitively matched the particular token. We used lists extensively as they are a flexible data structure and also because some Spotify methods required list parameters. 

​	We realized that we needed to protect our app secrets by using environment variables, so we created a .env file containing the secret values. We could then access these by using the `dotenv` and `os` libraries. For our website, we didn’t upload a `.env` file, but instead added these values directly as a configuration variable on our app dashboard. 

​	Heroku integration was also a difficult process, as we went through generating a requirements.txt, creating a Procfile, and generally researching how to host our server and site on the platform. Once we connected our program to Heroku, we realized that our search query was taking too long to load because of Heroku’s limit on computation time. We had to figure out a way to optimize our searches such that we would avoid the limit. Our technical solution was similar to a concept we utilized in Election Simulator, where we excluded previously computed recursive calls by storing them in a map that we check against before making recursive calls. In our program, we initialize a list of words to exclude from our next search, a list of “banned” words. Every time we found a song whose title was not exactly the query, we added everything in its title except for the query term to our list of banned words. But, we also had to deal with Spotify’s query character limit; in order to do so, we restricted the number of banned words. 

​	In addition, for our frontend we used `Bootstrap` CSS to style the site and decided to keep a clean minimal approach to our login and main page. We decided to use in-line styles in our HTML because we only had a few lines of styling and didn’t want our site to be slower because it had to load a separate stylesheet.

​	Finally, to authenticate users, we used a modified example of Spotify’s Authorization code flow that we found on StackOverflow (the exact post and user is mentioned in the comments of the code). We first requested authorization from Spotify, then Spotify would request authorization from a user and return back an access token. Then, everytime we would make a request to Spotify, we would have to use the access token (possibly refreshing if the time had expired) to access the web API. Jordan mentioned that using sessions and cookies would be necessary for this type of project, so we Flask’s built-in sessions tools. This part of the project involved a lot of learning as all of the material and processes were completely new, but now we have a more solid understanding of the authorization process, redirects and callbacks, access tokens, and cookies. 